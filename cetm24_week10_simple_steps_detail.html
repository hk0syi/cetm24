<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive SOM Training with Detailed Calculations</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .control-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .step-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .info-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #667eea;
        }
        
        .info-card h3 {
            margin-top: 0;
            color: #667eea;
            font-size: 1.2em;
        }
        
        .calculation-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border: 1px solid #e9ecef;
        }
        
        .formula {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-left: 4px solid #2196f3;
        }
        
        .calculation-step {
            background: #fff3e0;
            padding: 10px;
            border-radius: 6px;
            margin: 5px 0;
            font-family: 'Courier New', monospace;
            border-left: 3px solid #ff9800;
        }
        
        .result {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 6px;
            margin: 5px 0;
            font-weight: bold;
            border-left: 3px solid #4caf50;
        }
        
        .winner-highlight {
            background: #e8f5e8;
            color: #2e7d2e;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .plot-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .plot-title {
            text-align: center;
            margin-bottom: 15px;
            color: #667eea;
            font-weight: 600;
        }
        
        .data-tables {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
        }
        
        .table-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        th, td {
            padding: 8px 12px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
        }
        
        th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background: rgba(102, 126, 234, 0.1);
        }
        
        .current-step {
            background: rgba(102, 126, 234, 0.2);
            font-weight: bold;
        }
        
        .winner {
            background: rgba(40, 167, 69, 0.2);
            font-weight: bold;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e9ecef;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }
        
        .metric {
            display: inline-block;
            background: rgba(102, 126, 234, 0.1);
            padding: 5px 10px;
            border-radius: 15px;
            margin: 2px;
            font-weight: 600;
        }
        
        .detailed-calculations {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        
        .calc-section {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 10px;
            background: #f8f9fa;
        }
        
        .calc-title {
            color: #667eea;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .math-steps {
            font-family: 'Courier New', monospace;
            line-height: 1.6;
        }
        
        .step-number {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.9em;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Interactive SOM Training with Complete Mathematical Details</h1>
            <p>Step-by-step visualization with all calculations shown</p>
        </div>
        
        <div class="control-panel">
            <div class="controls">
                <button onclick="resetTraining()">üîÑ Reset</button>
                <button onclick="prevStep()" id="prevBtn">‚¨ÖÔ∏è Previous Step</button>
                <button onclick="nextStep()" id="nextBtn">‚û°Ô∏è Next Step</button>
                <button onclick="playAuto()" id="playBtn">‚ñ∂Ô∏è Auto Play</button>
                <button onclick="jumpToEpoch()" id="epochBtn">üéØ Jump to Epoch</button>
                <span class="metric" id="stepCounter">Step: 0/40</span>
                <span class="metric" id="epochCounter">Epoch: 0/10</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%"></div>
            </div>
        </div>
        
        <div class="detailed-calculations" id="detailedCalc">
            <h3>üìñ Complete Mathematical Breakdown</h3>
            <div id="calculationContent">
                <p>Detailed calculations will appear when training starts...</p>
            </div>
        </div>
        
        <div class="step-info">
            <div class="info-card">
                <h3>üìä Current Step Overview</h3>
                <div id="stepDetails">
                    <p><strong>Status:</strong> Ready to start training</p>
                    <p><strong>Sample:</strong> None</p>
                    <p><strong>Action:</strong> Initialize weights</p>
                </div>
            </div>
            
            <div class="info-card">
                <h3>üìà Training Progress</h3>
                <div id="trainingProgress">
                    <p><strong>Learning Rate (Œ∑):</strong> 0.8</p>
                    <p><strong>Total Epochs:</strong> <span id="totalEpochs">0</span></p>
                    <p><strong>Quantization Error:</strong> <span id="quantError">-</span></p>
                    <p><strong>Convergence:</strong> <span id="convergence">In progress</span></p>
                </div>
            </div>
        </div>
        
        <div class="visualization">
            <div class="plot-container">
                <div class="plot-title">üó∫Ô∏è 3D Weight Space Visualization</div>
                <canvas id="weightCanvas" width="400" height="300"></canvas>
                <div class="calculation-box">
                    <p><strong>Red points:</strong> Input samples X</p>
                    <p><strong>Blue/Green circles:</strong> Neuron weights W</p>
                    <p><strong>Yellow lines:</strong> Winner connections</p>
                </div>
            </div>
            
            <div class="plot-container">
                <div class="plot-title">üìâ Convergence Chart</div>
                <canvas id="convergenceCanvas" width="400" height="300"></canvas>
                <div class="calculation-box">
                    <p><strong>Blue line:</strong> Total weight change per epoch</p>
                    <p><strong>Red line:</strong> Convergence threshold (1e-5)</p>
                </div>
            </div>
        </div>
        
        <div class="data-tables">
            <div class="table-container">
                <h3>üìã Training Log</h3>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table id="trainingTable">
                        <thead>
                            <tr>
                                <th>Epoch</th>
                                <th>Step</th>
                                <th>Sample</th>
                                <th>Input [x‚ÇÅ,x‚ÇÇ,x‚ÇÉ]</th>
                                <th>Winner</th>
                                <th>Distance</th>
                                <th>Change Œî</th>
                            </tr>
                        </thead>
                        <tbody id="trainingBody">
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="table-container">
                <h3>üéØ Current Weights & Epoch Summary</h3>
                <table id="weightsTable">
                    <thead>
                        <tr>
                            <th>Neuron</th>
                            <th>w‚ÇÅ</th>
                            <th>w‚ÇÇ</th>
                            <th>w‚ÇÉ</th>
                            <th>Final Hits</th>
                        </tr>
                    </thead>
                    <tbody id="weightsBody">
                    </tbody>
                </table>
                
                <h3 style="margin-top: 20px;">üìä Epoch Summary</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table id="epochTable">
                        <thead>
                            <tr>
                                <th>Epoch</th>
                                <th>Total Change (Œî)</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="epochBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Training data and initial setup
        const X = [
            [0.8, 0.7, 0.4],
            [0.6, 0.9, 0.9],
            [0.3, 0.4, 0.1],
            [0.1, 0.1, 0.2]
        ];
        
        let W = [
            [0.5, 0.4],
            [0.6, 0.2],
            [0.8, 0.5]
        ];
        
        const initialW = [
            [0.5, 0.4],
            [0.6, 0.2],
            [0.8, 0.5]
        ];
        
        const learningRate = 0.8;
        let currentStep = 0;
        let maxSteps = 40;
        let trainingLog = [];
        let epochSummary = [];
        let isPlaying = false;
        let playInterval;
        
        // Calculate the complete training sequence with detailed steps
        function calculateTrainingSequence() {
            trainingLog = [];
            epochSummary = [];
            let tempW = JSON.parse(JSON.stringify(initialW));
            
            for (let epoch = 0; epoch < 10; epoch++) {
                let epochDelta = 0;
                
                for (let i = 0; i < X.length; i++) {
                    const x = X[i];
                    
                    // Calculate distances with detailed steps
                    const neuron0Calc = {
                        diff: [x[0] - tempW[0][0], x[1] - tempW[1][0], x[2] - tempW[2][0]],
                        squared: [],
                        sum: 0,
                        distance: 0
                    };
                    neuron0Calc.squared = neuron0Calc.diff.map(d => d * d);
                    neuron0Calc.sum = neuron0Calc.squared.reduce((a, b) => a + b, 0);
                    neuron0Calc.distance = Math.sqrt(neuron0Calc.sum);
                    
                    const neuron1Calc = {
                        diff: [x[0] - tempW[0][1], x[1] - tempW[1][1], x[2] - tempW[2][1]],
                        squared: [],
                        sum: 0,
                        distance: 0
                    };
                    neuron1Calc.squared = neuron1Calc.diff.map(d => d * d);
                    neuron1Calc.sum = neuron1Calc.squared.reduce((a, b) => a + b, 0);
                    neuron1Calc.distance = Math.sqrt(neuron1Calc.sum);
                    
                    const distances = [neuron0Calc.distance, neuron1Calc.distance];
                    const winner = distances[0] < distances[1] ? 0 : 1;
                    const winnerDistance = distances[winner];
                    
                    // Store old weights
                    const oldWeights = [tempW[0][winner], tempW[1][winner], tempW[2][winner]];
                    
                    // Update weights with detailed calculations
                    const updateCalc = {
                        learningRate: learningRate,
                        differences: [x[0] - oldWeights[0], x[1] - oldWeights[1], x[2] - oldWeights[2]],
                        adjustments: [],
                        newWeights: []
                    };
                    
                    updateCalc.adjustments = updateCalc.differences.map(d => learningRate * d);
                    updateCalc.newWeights = oldWeights.map((w, idx) => w + updateCalc.adjustments[idx]);
                    
                    // Apply updates
                    tempW[0][winner] = updateCalc.newWeights[0];
                    tempW[1][winner] = updateCalc.newWeights[1];
                    tempW[2][winner] = updateCalc.newWeights[2];
                    
                    // Calculate change magnitude with steps
                    const changeCalc = {
                        differences: updateCalc.newWeights.map((w, idx) => w - oldWeights[idx]),
                        squared: [],
                        sum: 0,
                        magnitude: 0
                    };
                    changeCalc.squared = changeCalc.differences.map(d => d * d);
                    changeCalc.sum = changeCalc.squared.reduce((a, b) => a + b, 0);
                    changeCalc.magnitude = Math.sqrt(changeCalc.sum);
                    
                    epochDelta += changeCalc.magnitude;
                    
                    trainingLog.push({
                        epoch: epoch + 1,
                        step: i + 1,
                        sampleIndex: i,
                        input: [...x],
                        neuron0Calc: neuron0Calc,
                        neuron1Calc: neuron1Calc,
                        distances: [...distances],
                        winner: winner,
                        oldWeights: [...oldWeights],
                        updateCalc: updateCalc,
                        changeCalc: changeCalc,
                        newWeights: [...updateCalc.newWeights],
                        changeMag: changeCalc.magnitude,
                        cumulativeDelta: epochDelta,
                        currentW: JSON.parse(JSON.stringify(tempW))
                    });
                }
                
                epochSummary.push({
                    epoch: epoch + 1,
                    totalChange: epochDelta,
                    weights: JSON.parse(JSON.stringify(tempW))
                });
                
                if (epochDelta < 1e-5) {
                    maxSteps = trainingLog.length;
                    break;
                }
            }
        }
        
        function updateDetailedCalculations() {
            const calcContent = document.getElementById('calculationContent');
            
            if (currentStep === 0) {
                calcContent.innerHTML = `
                    <div class="calc-section">
                        <div class="calc-title">Initial Setup</div>
                        <div class="formula">Input Data X (4 samples √ó 3 features):</div>
                        <div class="calculation-step">X = [[0.8, 0.7, 0.4], [0.6, 0.9, 0.9], [0.3, 0.4, 0.1], [0.1, 0.1, 0.2]]</div>
                        
                        <div class="formula">Initial Weights W (3 features √ó 2 neurons):</div>
                        <div class="calculation-step">Neuron 0: [0.5, 0.6, 0.8]</div>
                        <div class="calculation-step">Neuron 1: [0.4, 0.2, 0.5]</div>
                        
                        <div class="formula">Learning Rate Œ∑ = 0.8</div>
                        <div class="formula">Distance Formula: d = ‚àö[(x‚ÇÅ-w‚ÇÅ)¬≤ + (x‚ÇÇ-w‚ÇÇ)¬≤ + (x‚ÇÉ-w‚ÇÉ)¬≤]</div>
                        <div class="formula">Update Rule: w_new = w_old + Œ∑ √ó (x - w_old)</div>
                    </div>
                `;
                return;
            }
            
            const log = trainingLog[currentStep - 1];
            const stepInEpoch = (currentStep - 1) % 4 + 1;
            
            calcContent.innerHTML = `
                <div class="calc-section">
                    <div class="calc-title">
                        <span class="step-number">${currentStep}</span>
                        Epoch ${log.epoch}, Step ${stepInEpoch}: Processing Sample ${log.sampleIndex}
                    </div>
                    <div class="formula">Input: x = [${log.input.map(v => v.toFixed(1)).join(', ')}]</div>
                    <div class="formula">Current Weights Before Update:</div>
                    <div class="calculation-step">Neuron 0: [${log.currentW[0][0].toFixed(3)}, ${log.currentW[1][0].toFixed(3)}, ${log.currentW[2][0].toFixed(3)}]</div>
                    <div class="calculation-step">Neuron 1: [${log.currentW[0][1].toFixed(3)}, ${log.currentW[1][1].toFixed(3)}, ${log.currentW[2][1].toFixed(3)}]</div>
                </div>
                
                <div class="calc-section">
                    <div class="calc-title">Step 1: Calculate Distances</div>
                    
                    <div class="formula">Distance to Neuron 0:</div>
                    <div class="calculation-step">Differences: [${log.neuron0Calc.diff.map(d => d.toFixed(3)).join(', ')}]</div>
                    <div class="calculation-step">Squared: [${log.neuron0Calc.squared.map(s => s.toFixed(6)).join(', ')}]</div>
                    <div class="calculation-step">Sum: ${log.neuron0Calc.sum.toFixed(6)}</div>
                    <div class="result">d‚ÇÄ = ‚àö${log.neuron0Calc.sum.toFixed(6)} = ${log.neuron0Calc.distance.toFixed(6)}</div>
                    
                    <div class="formula">Distance to Neuron 1:</div>
                    <div class="calculation-step">Differences: [${log.neuron1Calc.diff.map(d => d.toFixed(3)).join(', ')}]</div>
                    <div class="calculation-step">Squared: [${log.neuron1Calc.squared.map(s => s.toFixed(6)).join(', ')}]</div>
                    <div class="calculation-step">Sum: ${log.neuron1Calc.sum.toFixed(6)}</div>
                    <div class="result">d‚ÇÅ = ‚àö${log.neuron1Calc.sum.toFixed(6)} = ${log.neuron1Calc.distance.toFixed(6)}</div>
                </div>
                
                <div class="calc-section">
                    <div class="calc-title">Step 2: Select Winner</div>
                    <div class="calculation-step">d‚ÇÄ = ${log.distances[0].toFixed(6)}</div>
                    <div class="calculation-step">d‚ÇÅ = ${log.distances[1].toFixed(6)}</div>
                    <div class="result winner-highlight">Winner: Neuron ${log.winner} (smaller distance)</div>
                </div>
                
                <div class="calc-section">
                    <div class="calc-title">Step 3: Update Winner Weights</div>
                    <div class="formula">Old weights: [${log.oldWeights.map(w => w.toFixed(3)).join(', ')}]</div>
                    
                    <div class="calculation-step">Differences (x - w_old): [${log.updateCalc.differences.map(d => d.toFixed(3)).join(', ')}]</div>
                    <div class="calculation-step">Adjustments (Œ∑ √ó differences): [${log.updateCalc.adjustments.map(a => a.toFixed(3)).join(', ')}]</div>
                    
                    <div class="formula">Weight Updates (w_new = w_old + Œ∑ √ó (x - w_old)):</div>
                    <div class="calculation-step">w‚ÇÅ: ${log.oldWeights[0].toFixed(3)} + ${log.updateCalc.adjustments[0].toFixed(3)} = ${log.updateCalc.newWeights[0].toFixed(3)}</div>
                    <div class="calculation-step">w‚ÇÇ: ${log.oldWeights[1].toFixed(3)} + ${log.updateCalc.adjustments[1].toFixed(3)} = ${log.updateCalc.newWeights[1].toFixed(3)}</div>
                    <div class="calculation-step">w‚ÇÉ: ${log.oldWeights[2].toFixed(3)} + ${log.updateCalc.adjustments[2].toFixed(3)} = ${log.updateCalc.newWeights[2].toFixed(3)}</div>
                    
                    <div class="result">New weights: [${log.updateCalc.newWeights.map(w => w.toFixed(3)).join(', ')}]</div>
                </div>
                
                <div class="calc-section">
                    <div class="calc-title">Step 4: Calculate Change Magnitude</div>
                    <div class="calculation-step">Weight changes: [${log.changeCalc.differences.map(d => d.toFixed(3)).join(', ')}]</div>
                    <div class="calculation-step">Squared changes: [${log.changeCalc.squared.map(s => s.toFixed(6)).join(', ')}]</div>
                    <div class="calculation-step">Sum: ${log.changeCalc.sum.toFixed(6)}</div>
                    <div class="result">Change magnitude: ‚àö${log.changeCalc.sum.toFixed(6)} = ${log.changeCalc.magnitude.toFixed(6)}</div>
                    <div class="result">Cumulative epoch change: ${log.cumulativeDelta.toFixed(6)}</div>
                </div>
            `;
        }
        
        function updateDisplay() {
            // Update counters
            document.getElementById('stepCounter').textContent = `Step: ${currentStep}/${maxSteps}`;
            const currentEpoch = currentStep === 0 ? 0 : Math.ceil(currentStep / 4);
            document.getElementById('epochCounter').textContent = `Epoch: ${currentEpoch}/10`;
            
            // Update progress bar
            const progress = (currentStep / maxSteps) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
            
            // Update detailed calculations
            updateDetailedCalculations();
            
            // Update step details
            updateStepDetails();
            
            // Update weights table
            updateWeightsTable();
            
            // Update training table
            updateTrainingTable();
            
            // Update epoch summary
            updateEpochTable();
            
            // Update visualizations
            updateWeightVisualization();
            updateConvergenceChart();
            
            // Update navigation buttons
            document.getElementById('prevBtn').disabled = currentStep === 0;
            document.getElementById('nextBtn').disabled = currentStep >= maxSteps;
        }
        
        function updateStepDetails() {
            const stepDetails = document.getElementById('stepDetails');
            const progress = document.getElementById('trainingProgress');
            
            if (currentStep === 0) {
                stepDetails.innerHTML = `
                    <p><strong>Status:</strong> Initial state</p>
                    <p><strong>Sample:</strong> None</p>
                    <p><strong>Action:</strong> Ready to start training</p>
                `;
            } else {
                const log = trainingLog[currentStep - 1];
                const currentEpoch = Math.ceil(currentStep / 4);
                const epochData = epochSummary[currentEpoch - 1];
                
                stepDetails.innerHTML = `
                    <p><strong>Status:</strong> Training step ${currentStep}</p>
                    <p><strong>Sample:</strong> ${log.sampleIndex} [${log.input.map(x => x.toFixed(1)).join(', ')}]</p>
                    <p><strong>Winner:</strong> <span class="winner-highlight">Neuron ${log.winner}</span></p>
                    <p><strong>Distance:</strong> ${log.distances[log.winner].toFixed(6)}</p>
                    <p><strong>Weight Change:</strong> ${log.changeMag.toFixed(6)}</p>
                `;
                
                if (epochData) {
                    const totalEpochs = epochSummary.length;
                    const quantError = calculateQuantizationError(log.currentW);
                    const isConverged = epochData.totalChange < 1e-5;
                    
                    document.getElementById('totalEpochs').textContent = totalEpochs;
                    document.getElementById('quantError').textContent = quantError.toFixed(6);
                    document.getElementById('convergence').textContent = isConverged ? 'Converged!' : 'In progress';
                }
            }
        }
        
        function calculateQuantizationError(weights) {
            let totalError = 0;
            for (let i = 0; i < X.length; i++) {
                const x = X[i];
                const distances = [
                    Math.sqrt(Math.pow(x[0] - weights[0][0], 2) + Math.pow(x[1] - weights[1][0], 2) + Math.pow(x[2] - weights[2][0], 2)),
                    Math.sqrt(Math.pow(x[0] - weights[0][1], 2) + Math.pow(x[1] - weights[1][1], 2) + Math.pow(x[2] - weights[2][1], 2))
                ];
                totalError += Math.min(...distances);
            }
            return totalError / X.length;
        }
        
        function updateWeightsTable() {
            const tbody = document.getElementById('weightsBody');
            let weights = initialW;
            let hits = [0, 0];
            
            if (currentStep > 0) {
                weights = trainingLog[currentStep - 1].currentW;
                
                // Calculate hits for current weights
                hits = [0, 0];
                for (let i = 0; i < X.length; i++) {
                    const x = X[i];
                    const distances = [
                        Math.sqrt(Math.pow(x[0] - weights[0][0], 2) + Math.pow(x[1] - weights[1][0], 2) + Math.pow(x[2] - weights[2][0], 2)),
                        Math.sqrt(Math.pow(x[0] - weights[0][1], 2) + Math.pow(x[1] - weights[1][1], 2) + Math.pow(x[2] - weights[2][1], 2))
                    ];
                    const winner = distances[0] < distances[1] ? 0 : 1;
                    hits[winner]++;
                }
            }
            
            tbody.innerHTML = '';
            for (let i = 0; i < 2; i++) {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>Neuron ${i}</td>
                    <td>${weights[0][i].toFixed(6)}</td>
                    <td>${weights[1][i].toFixed(6)}</td>
                    <td>${weights[2][i].toFixed(6)}</td>
                    <td>${hits[i]}</td>
                `;
                
                if (currentStep > 0 && trainingLog[currentStep - 1].winner === i) {
                    row.className = 'winner';
                }
            }
        }
        
        function updateTrainingTable() {
            const tbody = document.getElementById('trainingBody');
            tbody.innerHTML = '';
            
            const startIdx = Math.max(0, currentStep - 10);
            const endIdx = Math.min(currentStep, trainingLog.length);
            
            for (let i = startIdx; i < endIdx; i++) {
                const log = trainingLog[i];
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${log.epoch}</td>
                    <td>${log.step}</td>
                    <td>${log.sampleIndex}</td>
                    <td>[${log.input.map(x => x.toFixed(1)).join(',')}]</td>
                    <td class="winner">Neuron ${log.winner}</td>
                    <td>${log.distances[log.winner].toFixed(4)}</td>
                    <td>${log.changeMag.toFixed(4)}</td>
                `;
                
                if (i === currentStep - 1) {
                    row.className = 'current-step';
                }
            }
        }
        
        function updateEpochTable() {
            const tbody = document.getElementById('epochBody');
            tbody.innerHTML = '';
            
            for (let i = 0; i < epochSummary.length; i++) {
                const epoch = epochSummary[i];
                const row = tbody.insertRow();
                const isConverged = epoch.totalChange < 1e-5;
                row.innerHTML = `
                    <td>${epoch.epoch}</td>
                    <td>${epoch.totalChange.toFixed(6)}</td>
                    <td>${isConverged ? '‚úÖ Converged' : 'üîÑ Training'}</td>
                `;
            }
        }
        
        function updateWeightVisualization() {
            const canvas = document.getElementById('weightCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set up 3D-like projection
            const scale = 150;
            const offsetX = canvas.width / 2;
            const offsetY = canvas.height / 2;
            
            // Get current weights
            let weights = initialW;
            if (currentStep > 0) {
                weights = trainingLog[currentStep - 1].currentW;
            }
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * canvas.width;
                const y = (i / 10) * canvas.height;
                
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw input samples (red points)
            ctx.fillStyle = '#dc3545';
            for (let i = 0; i < X.length; i++) {
                const x = X[i];
                const projX = offsetX + (x[0] - 0.5) * scale;
                const projY = offsetY - (x[1] - 0.5) * scale;
                
                ctx.beginPath();
                ctx.arc(projX, projY, 8, 0, 2 * Math.PI);
                ctx.fill();
                
                // Label
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.fillText(`S${i}`, projX + 10, projY - 10);
                ctx.fillStyle = '#dc3545';
            }
            
            // Draw neuron weights
            for (let i = 0; i < 2; i++) {
                const w = [weights[0][i], weights[1][i], weights[2][i]];
                const projX = offsetX + (w[0] - 0.5) * scale;
                const projY = offsetY - (w[1] - 0.5) * scale;
                
                ctx.fillStyle = i === 0 ? '#007bff' : '#28a745';
                ctx.beginPath();
                ctx.arc(projX, projY, 10, 0, 2 * Math.PI);
                ctx.fill();
                
                // White center
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(projX, projY, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Label
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.fillText(`N${i}`, projX + 12, projY - 12);
                
                // Draw winner connection
                if (currentStep > 0) {
                    const log = trainingLog[currentStep - 1];
                    if (log.winner === i) {
                        const sampleX = X[log.sampleIndex];
                        const sampleProjX = offsetX + (sampleX[0] - 0.5) * scale;
                        const sampleProjY = offsetY - (sampleX[1] - 0.5) * scale;
                        
                        ctx.strokeStyle = '#ffc107';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(projX, projY);
                        ctx.lineTo(sampleProjX, sampleProjY);
                        ctx.stroke();
                    }
                }
            }
        }
        
        function updateConvergenceChart() {
            const canvas = document.getElementById('convergenceCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (epochSummary.length === 0) return;
            
            // Set up chart area
            const margin = 40;
            const chartWidth = canvas.width - 2 * margin;
            const chartHeight = canvas.height - 2 * margin;
            
            // Find max value for scaling
            const maxChange = Math.max(...epochSummary.map(e => e.totalChange));
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, margin + chartHeight);
            ctx.lineTo(margin + chartWidth, margin + chartHeight);
            ctx.stroke();
            
            // Draw convergence line
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < epochSummary.length; i++) {
                const x = margin + (i / Math.max(1, epochSummary.length - 1)) * chartWidth;
                const y = margin + chartHeight - (epochSummary[i].totalChange / maxChange) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // Draw point
                ctx.fillStyle = '#007bff';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.stroke();
            
            // Draw tolerance line
            const toleranceY = margin + chartHeight - (1e-5 / maxChange) * chartHeight;
            if (toleranceY > margin && toleranceY < margin + chartHeight) {
                ctx.strokeStyle = '#dc3545';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(margin, toleranceY);
                ctx.lineTo(margin + chartWidth, toleranceY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Label
                ctx.fillStyle = '#dc3545';
                ctx.font = '12px Arial';
                ctx.fillText('Tolerance (1e-5)', margin + chartWidth - 100, toleranceY - 5);
            }
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('Epoch', margin + chartWidth/2 - 20, canvas.height - 10);
            
            ctx.save();
            ctx.translate(15, margin + chartHeight/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Total Change (Œî)', -50, 0);
            ctx.restore();
        }
        
        function nextStep() {
            if (currentStep < maxSteps) {
                currentStep++;
                updateDisplay();
            }
        }
        
        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                updateDisplay();
            }
        }
        
        function resetTraining() {
            currentStep = 0;
            stopAutoPlay();
            updateDisplay();
        }
        
        function playAuto() {
            if (isPlaying) {
                stopAutoPlay();
            } else {
                isPlaying = true;
                document.getElementById('playBtn').textContent = '‚è∏Ô∏è Pause';
                playInterval = setInterval(() => {
                    if (currentStep < maxSteps) {
                        nextStep();
                    } else {
                        stopAutoPlay();
                    }
                }, 2000); // Slower for detailed viewing
            }
        }
        
        function stopAutoPlay() {
            isPlaying = false;
            document.getElementById('playBtn').textContent = '‚ñ∂Ô∏è Auto Play';
            if (playInterval) {
                clearInterval(playInterval);
            }
        }
        
        function jumpToEpoch() {
            const epoch = prompt('Enter epoch number (1-10):');
            if (epoch && !isNaN(epoch)) {
                const epochNum = parseInt(epoch);
                if (epochNum >= 1 && epochNum <= 10) {
                    currentStep = Math.min(epochNum * 4, maxSteps);
                    updateDisplay();
                }
            }
        }
        
        // Initialize
        calculateTrainingSequence();
        updateDisplay();
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    nextStep();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    prevStep();
                    break;
                case 'r':
                    resetTraining();
                    break;
                case 'p':
                    playAuto();
                    break;
            }
        });
    </script>
</body>
</html>