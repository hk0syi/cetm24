<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Classifier - MLP & RBF</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .tabs {
            display: flex;
            background: #f7fafc;
            border-radius: 15px;
            padding: 5px;
            margin-bottom: 30px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .tab {
            flex: 1;
            padding: 15px 25px;
            text-align: center;
            background: transparent;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            color: #4a5568;
        }
        
        .tab.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            margin: 25px 0;
            padding: 20px;
            border-radius: 15px;
            background: linear-gradient(145deg, #f7fafc, #edf2f7);
            border-left: 5px solid #667eea;
        }
        
        .data-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        th, td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
        }
        
        th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
        }
        
        tr:hover {
            background-color: #f7fafc;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }
        
        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        input[type="number"] {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .log {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-line;
            margin: 20px 0;
        }
        
        .prediction-section {
            background: linear-gradient(145deg, #e6fffa, #b2f5ea);
            border-left: 5px solid #38b2ac;
        }
        
        .result-box {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #48bb78, #38a169);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .rbf-section {
            border-left: 5px solid #ed8936;
        }
        
        .centers-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .center-box {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .calculation-step {
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            margin: 10px 0;
            padding: 20px;
            border-radius: 15px;
            border-left: 4px solid #ed8936;
            position: relative;
        }
        
        .calculation-step h5 {
            color: #ed8936;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }
        
        .math-formula {
            background: #2d3748;
            color: #e2e8f0;
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            overflow-x: auto;
        }
        
        .value-highlight {
            background: #fef5e7;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            color: #dd6b20;
        }
        
        .detailed-calculations {
            display: none;
            margin-top: 20px;
        }
        
        .detailed-calculations.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 1000px;
            }
        }
        
        .step-number {
            background: #ed8936;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† Neural Network Classifier</h1>
        
        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" onclick="switchTab('mlp')">üîó Multi-Layer Perceptron</button>
            <button class="tab" onclick="switchTab('rbf')">‚ö™ Radial Basis Function</button>
        </div>
        
        <!-- MLP Tab Content -->
        <div id="mlp-content" class="tab-content active">
            <div class="section">
                <h2>üìä Training Data</h2>
                <div class="data-display">
                    <div>
                        <h3>Input Features (X)</h3>
                        <table id="inputTable">
                            <thead>
                                <tr><th>Point</th><th>x1</th><th>x2</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div>
                        <h3>Target Labels (y)</h3>
                        <table id="outputTable">
                            <thead>
                                <tr><th>Point</th><th>Class A</th><th>Class B</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>‚öôÔ∏è MLP Configuration</h2>
                <div class="controls">
                    <label>Hidden Units: <input type="number" id="hiddenUnits" value="4" min="2" max="20"></label>
                    <label>Learning Rate: <input type="number" id="learningRate" value="0.1" step="0.01" min="0.01" max="1"></label>
                    <label>Epochs: <input type="number" id="epochs" value="1000" min="100" max="10000" step="100"></label>
                    <button id="trainBtn" onclick="trainMLP()">üöÄ Train MLP</button>
                    <button id="resetBtn" onclick="resetMLP()">üîÑ Reset</button>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="section">
                <h2>üìà Training Progress</h2>
                <div id="trainingLog" class="log">Ready to train MLP...</div>
            </div>
            
            <div class="section prediction-section">
                <h2>üîÆ MLP Predictions</h2>
                <div class="controls">
                    <label>x1: <input type="number" id="predX1" value="3" step="0.1"></label>
                    <label>x2: <input type="number" id="predX2" value="2" step="0.1"></label>
                    <button onclick="makePredictionMLP()">üéØ Predict</button>
                    <button onclick="testTrainingDataMLP()">‚úÖ Test Training Data</button>
                </div>
                <div id="predictionResults" class="result-box"></div>
            </div>
        </div>
        
        <!-- RBF Tab Content -->
        <div id="rbf-content" class="tab-content">
            <div class="section">
                <h2>üìä Training Data</h2>
                <div class="data-display">
                    <div>
                        <h3>Input Features (X)</h3>
                        <table id="inputTableRBF">
                            <thead>
                                <tr><th>Point</th><th>x1</th><th>x2</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <div>
                        <h3>Target Labels (y)</h3>
                        <table id="outputTableRBF">
                            <thead>
                                <tr><th>Point</th><th>Class A</th><th>Class B</th></tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <div class="section rbf-section">
                <h2>‚öôÔ∏è RBF Configuration</h2>
                <div class="controls">
                    <label>K Centers: <input type="number" id="kCenters" value="2" min="1" max="4"></label>
                    <label>Max Iterations: <input type="number" id="maxIter" value="100" min="10" max="500"></label>
                    <button onclick="trainRBF()">üöÄ Train RBF</button>
                    <button onclick="resetRBF()">üîÑ Reset</button>
                </div>
            </div>
            
            <div class="section rbf-section">
                <h2>üéØ RBF Centers & Parameters</h2>
                <div id="centersDisplay" class="centers-display">
                    <p>Train the network to see RBF centers...</p>
                </div>
                <div id="rbfParams" class="result-box">
                    <p>RBF parameters will appear here after training...</p>
                </div>
            </div>
            
            <div class="section">
                <h2>üìà RBF Training Log</h2>
                <div id="trainingLogRBF" class="log">Ready to train RBF...</div>
            </div>
            
            <div class="section prediction-section">
                <h2>üîÆ RBF Predictions</h2>
                <div class="controls">
                    <label>x1: <input type="number" id="predX1RBF" value="3" step="0.1"></label>
                    <label>x2: <input type="number" id="predX2RBF" value="2" step="0.1"></label>
                    <button onclick="makePredictionRBF()">üéØ Predict</button>
                    <button onclick="testTrainingDataRBF()">‚úÖ Test Training Data</button>
                    <button onclick="toggleRBFCalculations()" id="toggleCalcBtn" style="background: linear-gradient(45deg, #ed8936, #dd6b20);">üîç Show Detailed Math</button>
                </div>
                <div id="predictionResultsRBF" class="result-box"></div>
            </div>
        </div>
    </div>

    <script>
        // Training Data
        const X = [
            [1, 1],
            [2, 1],
            [4, 3],
            [5, 4]
        ];
        
        const y = [
            [1, 0],  // Class A
            [1, 0],  // Class A
            [0, 1],  // Class B
            [0, 1]   // Class B
        ];
        
        // Global variables
        let mlp = null;
        let rbfNetwork = null;
        let showDetailedCalculations = false;
        
        // Tab switching
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-content').classList.add('active');
            event.target.classList.add('active');
        }
        
        // ==============================================
        // MLP Implementation
        // ==============================================
        
        class MLP {
            constructor(inputSize, hiddenSize, outputSize, learningRate) {
                this.inputSize = inputSize;
                this.hiddenSize = hiddenSize;
                this.outputSize = outputSize;
                this.learningRate = learningRate;
                
                // Initialize weights with random values
                this.W1 = this.randomMatrix(inputSize, hiddenSize);
                this.b1 = this.randomMatrix(1, hiddenSize)[0];
                this.W2 = this.randomMatrix(hiddenSize, outputSize);
                this.b2 = this.randomMatrix(1, outputSize)[0];
            }
            
            randomMatrix(rows, cols) {
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = (Math.random() - 0.5) * 2;
                    }
                }
                return matrix;
            }
            
            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
            }
            
            sigmoidDerivative(x) {
                return x * (1 - x);
            }
            
            forward(input) {
                // Hidden layer
                this.z1 = [];
                for (let j = 0; j < this.hiddenSize; j++) {
                    let sum = this.b1[j];
                    for (let i = 0; i < this.inputSize; i++) {
                        sum += input[i] * this.W1[i][j];
                    }
                    this.z1[j] = sum;
                }
                
                this.a1 = this.z1.map(z => this.sigmoid(z));
                
                // Output layer
                this.z2 = [];
                for (let j = 0; j < this.outputSize; j++) {
                    let sum = this.b2[j];
                    for (let i = 0; i < this.hiddenSize; i++) {
                        sum += this.a1[i] * this.W2[i][j];
                    }
                    this.z2[j] = sum;
                }
                
                this.a2 = this.z2.map(z => this.sigmoid(z));
                return this.a2;
            }
            
            backward(input, target, prediction) {
                // Output layer error
                const outputError = [];
                for (let i = 0; i < this.outputSize; i++) {
                    outputError[i] = (target[i] - prediction[i]) * this.sigmoidDerivative(prediction[i]);
                }
                
                // Hidden layer error
                const hiddenError = [];
                for (let i = 0; i < this.hiddenSize; i++) {
                    let sum = 0;
                    for (let j = 0; j < this.outputSize; j++) {
                        sum += outputError[j] * this.W2[i][j];
                    }
                    hiddenError[i] = sum * this.sigmoidDerivative(this.a1[i]);
                }
                
                // Update weights and biases
                for (let i = 0; i < this.hiddenSize; i++) {
                    for (let j = 0; j < this.outputSize; j++) {
                        this.W2[i][j] += this.learningRate * outputError[j] * this.a1[i];
                    }
                }
                
                for (let i = 0; i < this.outputSize; i++) {
                    this.b2[i] += this.learningRate * outputError[i];
                }
                
                for (let i = 0; i < this.inputSize; i++) {
                    for (let j = 0; j < this.hiddenSize; j++) {
                        this.W1[i][j] += this.learningRate * hiddenError[j] * input[i];
                    }
                }
                
                for (let i = 0; i < this.hiddenSize; i++) {
                    this.b1[i] += this.learningRate * hiddenError[i];
                }
            }
            
            train(X, y, epochs) {
                const losses = [];
                for (let epoch = 0; epoch < epochs; epoch++) {
                    let totalLoss = 0;
                    
                    for (let i = 0; i < X.length; i++) {
                        const prediction = this.forward(X[i]);
                        this.backward(X[i], y[i], prediction);
                        
                        let loss = 0;
                        for (let j = 0; j < this.outputSize; j++) {
                            loss += Math.pow(y[i][j] - prediction[j], 2);
                        }
                        totalLoss += loss;
                    }
                    
                    totalLoss /= X.length;
                    losses.push(totalLoss);
                    
                    if (epoch % 100 === 0) {
                        updateProgress(epoch / epochs * 100);
                        logTraining(`Epoch ${epoch}: Loss = ${totalLoss.toFixed(6)}`);
                    }
                }
                return losses;
            }
            
            predict(input) {
                return this.forward(input);
            }
        }
        
        // ==============================================
        // RBF Implementation
        // ==============================================
        
        class RBFNetwork {
            constructor(k) {
                this.k = k;
                this.centers = null;
                this.sigma = null;
                this.weights = null;
                this.dMax = null;
            }
            
            // K-means clustering to find RBF centers
            kMeans(X, k, maxIter = 100) {
                const n = X.length;
                const dim = X[0].length;
                
                // Initialize centers randomly
                let centers = [];
                for (let i = 0; i < k; i++) {
                    const randomIndex = Math.floor(Math.random() * n);
                    centers.push([...X[randomIndex]]);
                }
                
                for (let iter = 0; iter < maxIter; iter++) {
                    // Assign points to closest centers
                    const assignments = [];
                    for (let i = 0; i < n; i++) {
                        let minDist = Infinity;
                        let closestCenter = 0;
                        
                        for (let j = 0; j < k; j++) {
                            const dist = this.euclideanDistance(X[i], centers[j]);
                            if (dist < minDist) {
                                minDist = dist;
                                closestCenter = j;
                            }
                        }
                        assignments.push(closestCenter);
                    }
                    
                    // Update centers
                    const newCenters = [];
                    for (let j = 0; j < k; j++) {
                        const clusterPoints = [];
                        for (let i = 0; i < n; i++) {
                            if (assignments[i] === j) {
                                clusterPoints.push(X[i]);
                            }
                        }
                        
                        if (clusterPoints.length > 0) {
                            const centroid = [];
                            for (let d = 0; d < dim; d++) {
                                const sum = clusterPoints.reduce((acc, point) => acc + point[d], 0);
                                centroid.push(sum / clusterPoints.length);
                            }
                            newCenters.push(centroid);
                        } else {
                            newCenters.push([...centers[j]]);
                        }
                    }
                    
                    // Check convergence
                    let converged = true;
                    for (let j = 0; j < k; j++) {
                        for (let d = 0; d < dim; d++) {
                            if (Math.abs(centers[j][d] - newCenters[j][d]) > 1e-6) {
                                converged = false;
                                break;
                            }
                        }
                        if (!converged) break;
                    }
                    
                    centers = newCenters;
                    if (converged) break;
                }
                
                return centers;
            }
            
            euclideanDistance(a, b) {
                let sum = 0;
                for (let i = 0; i < a.length; i++) {
                    sum += Math.pow(a[i] - b[i], 2);
                }
                return Math.sqrt(sum);
            }
            
            // RBF activation function
            rbf(x, center, dMax, m1) {
                const dist2 = this.euclideanDistance(x, center) ** 2;
                return Math.exp(-(m1 / (dMax ** 2)) * dist2);
            }
            
            // Matrix operations
            matrixMultiply(A, B) {
                const result = [];
                for (let i = 0; i < A.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < B[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < B.length; k++) {
                            sum += A[i][k] * B[k][j];
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            }
            
            transpose(matrix) {
                return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
            }
            
            pseudoInverse(matrix) {
                const mt = this.transpose(matrix);
                const mtm = this.matrixMultiply(mt, matrix);
                const inv = this.matrixInverse(mtm);
                return this.matrixMultiply(inv, mt);
            }
            
            matrixInverse(matrix) {
                const n = matrix.length;
                const identity = [];
                const augmented = [];
                
                // Create identity matrix
                for (let i = 0; i < n; i++) {
                    identity[i] = [];
                    for (let j = 0; j < n; j++) {
                        identity[i][j] = i === j ? 1 : 0;
                    }
                }
                
                // Create augmented matrix
                for (let i = 0; i < n; i++) {
                    augmented[i] = [...matrix[i], ...identity[i]];
                }
                
                // Gauss-Jordan elimination
                for (let i = 0; i < n; i++) {
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    
                    [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
                    
                    const pivot = augmented[i][i];
                    for (let j = 0; j < 2 * n; j++) {
                        augmented[i][j] /= pivot;
                    }
                    
                    for (let k = 0; k < n; k++) {
                        if (k !== i) {
                            const factor = augmented[k][i];
                            for (let j = 0; j < 2 * n; j++) {
                                augmented[k][j] -= factor * augmented[i][j];
                            }
                        }
                    }
                }
                
                // Extract inverse matrix
                const inverse = [];
                for (let i = 0; i < n; i++) {
                    inverse[i] = augmented[i].slice(n);
                }
                
                return inverse;
            }
            
            train(X, y) {
                // Step 1: Find centers using K-means
                this.centers = this.kMeans(X, this.k);
                
                // Step 2: Compute spread parameter
                let maxDist = 0;
                for (let i = 0; i < this.centers.length; i++) {
                    for (let j = i + 1; j < this.centers.length; j++) {
                        const dist = this.euclideanDistance(this.centers[i], this.centers[j]);
                        maxDist = Math.max(maxDist, dist);
                    }
                }
                this.dMax = maxDist;
                this.sigma = maxDist / Math.sqrt(this.k);
                
                // Step 3: Build hidden activation matrix H
                const H = [];
                for (let i = 0; i < X.length; i++) {
                    H[i] = [];
                    for (let j = 0; j < this.k; j++) {
                        H[i][j] = this.rbf(X[i], this.centers[j], this.dMax, this.k);
                    }
                }
                
                // Step 4: Solve for output weights using pseudo-inverse
                const Hplus = this.pseudoInverse(H);
                this.weights = this.matrixMultiply(Hplus, y);
                
                return {
                    centers: this.centers,
                    dMax: this.dMax,
                    sigma: this.sigma,
                    hiddenMatrix: H,
                    weights: this.weights
                };
            }
            
            predict(X) {
                const predictions = [];
                const classes = [];
                
                for (let i = 0; i < X.length; i++) {
                    const H_new = [];
                    for (let j = 0; j < this.k; j++) {
                        H_new.push(this.rbf(X[i], this.centers[j], this.dMax, this.k));
                    }
                    
                    const output = [];
                    for (let j = 0; j < this.weights[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < this.k; k++) {
                            sum += H_new[k] * this.weights[k][j];
                        }
                        output.push(sum);
                    }
                    
                    predictions.push(output);
                    
                    // Find predicted class (argmax)
                    let maxIdx = 0;
                    for (let j = 1; j < output.length; j++) {
                        if (output[j] > output[maxIdx]) {
                            maxIdx = j;
                        }
                    }
                    classes.push(maxIdx + 1);
                }
                
                return { predictions, classes };
            }
        }
        
        // ==============================================
        // UI Functions
        // ==============================================
        
        function initializeDisplay() {
            // Display training data for both tabs
            const tables = [
                { input: '#inputTable tbody', output: '#outputTable tbody' },
                { input: '#inputTableRBF tbody', output: '#outputTableRBF tbody' }
            ];
            
            tables.forEach(table => {
                const inputTableBody = document.querySelector(table.input);
                const outputTableBody = document.querySelector(table.output);
                
                if (inputTableBody && outputTableBody) {
                    inputTableBody.innerHTML = '';
                    outputTableBody.innerHTML = '';
                    
                    for (let i = 0; i < X.length; i++) {
                        const inputRow = `<tr><td>Point ${i+1}</td><td>${X[i][0]}</td><td>${X[i][1]}</td></tr>`;
                        const outputRow = `<tr><td>Point ${i+1}</td><td>${y[i][0]}</td><td>${y[i][1]}</td></tr>`;
                        inputTableBody.innerHTML += inputRow;
                        outputTableBody.innerHTML += outputRow;
                    }
                }
            });
        }
        
        function updateProgress(percent) {
            document.getElementById('progressFill').style.width = percent + '%';
        }
        
        function logTraining(message) {
            const log = document.getElementById('trainingLog');
            log.textContent += message + '\n';
            log.scrollTop = log.scrollHeight;
        }
        
        function logRBF(message) {
            const log = document.getElementById('trainingLogRBF');
            log.textContent += message + '\n';
            log.scrollTop = log.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('trainingLog').textContent = 'Training started...\n';
        }
        
        function clearLogRBF() {
            document.getElementById('trainingLogRBF').textContent = 'Training started...\n';
        }
        
        // ==============================================
        // MLP Functions
        // ==============================================
        
        async function trainMLP() {
            const hiddenUnits = parseInt(document.getElementById('hiddenUnits').value);
            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const epochs = parseInt(document.getElementById('epochs').value);
            
            document.getElementById('trainBtn').disabled = true;
            clearLog();
            
            mlp = new MLP(2, hiddenUnits, 2, learningRate);
            
            logTraining(`MLP Configuration:
- Input: 2 neurons
- Hidden: ${hiddenUnits} neurons  
- Output: 2 neurons
- Learning Rate: ${learningRate}
- Epochs: ${epochs}\n`);
            
            const startTime = Date.now();
            const losses = mlp.train(X, y, epochs);
            const endTime = Date.now();
            
            updateProgress(100);
            logTraining(`\nTraining completed in ${endTime - startTime}ms`);
            logTraining(`Final Loss: ${losses[losses.length - 1].toFixed(6)}`);
            
            document.getElementById('trainBtn').disabled = false;
            setTimeout(testTrainingDataMLP, 500);
        }
        
        function makePredictionMLP() {
            if (!mlp) {
                alert('Please train the MLP first!');
                return;
            }
            
            const x1 = parseFloat(document.getElementById('predX1').value);
            const x2 = parseFloat(document.getElementById('predX2').value);
            
            const prediction = mlp.predict([x1, x2]);
            
            const resultsDiv = document.getElementById('predictionResults');
            resultsDiv.innerHTML = `
                <h3>üéØ MLP Prediction for input [${x1}, ${x2}]:</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="text-align: center; padding: 15px; background: #fed7d7; border-radius: 10px;">
                        <strong>Class A</strong><br>
                        <span style="font-size: 1.5em; color: #e53e3e;">${(prediction[0] * 100).toFixed(1)}%</span>
                    </div>
                    <div style="text-align: center; padding: 15px; background: #c6f6d5; border-radius: 10px;">
                        <strong>Class B</strong><br>
                        <span style="font-size: 1.5em; color: #38a169;">${(prediction[1] * 100).toFixed(1)}%</span>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 15px; font-size: 1.2em;">
                    <strong>Predicted Class: ${prediction[0] > prediction[1] ? 'A' : 'B'}</strong>
                </div>
            `;
        }
        
        function testTrainingDataMLP() {
            if (!mlp) {
                alert('Please train the MLP first!');
                return;
            }
            
            let resultsHTML = '<h3>‚úÖ MLP Training Data Predictions:</h3><table style="width: 100%"><thead><tr><th>Input</th><th>Target</th><th>Prediction</th><th>Accuracy</th></tr></thead><tbody>';
            
            let totalAccuracy = 0;
            
            for (let i = 0; i < X.length; i++) {
                const prediction = mlp.predict(X[i]);
                const targetClass = y[i][0] > y[i][1] ? 'A' : 'B';
                const predictedClass = prediction[0] > prediction[1] ? 'A' : 'B';
                const isCorrect = targetClass === predictedClass;
                
                totalAccuracy += isCorrect ? 1 : 0;
                
                resultsHTML += `
                    <tr style="background: ${isCorrect ? '#c6f6d5' : '#fed7d7'}">
                        <td>[${X[i][0]}, ${X[i][1]}]</td>
                        <td>Class ${targetClass}</td>
                        <td>Class ${predictedClass} (${(Math.max(...prediction) * 100).toFixed(1)}%)</td>
                        <td>${isCorrect ? '‚úÖ Correct' : '‚ùå Wrong'}</td>
                    </tr>
                `;
            }
            
            resultsHTML += `</tbody></table><div style="text-align: center; margin-top: 15px; font-size: 1.2em;"><strong>Overall Accuracy: ${((totalAccuracy / X.length) * 100).toFixed(1)}%</strong></div>`;
            
            document.getElementById('predictionResults').innerHTML = resultsHTML;
        }
        
        function resetMLP() {
            mlp = null;
            updateProgress(0);
            document.getElementById('trainingLog').textContent = 'Ready to train MLP...';
            document.getElementById('predictionResults').innerHTML = '<p>Train the network and make predictions here...</p>';
        }
        
        // ==============================================
        // RBF Functions
        // ==============================================
        
        function toggleRBFCalculations() {
            showDetailedCalculations = !showDetailedCalculations;
            const btn = document.getElementById('toggleCalcBtn');
            
            if (showDetailedCalculations) {
                btn.textContent = 'üôà Hide Detailed Math';
                btn.style.background = 'linear-gradient(45deg, #38a169, #2f855a)';
            } else {
                btn.textContent = 'üîç Show Detailed Math';
                btn.style.background = 'linear-gradient(45deg, #ed8936, #dd6b20)';
            }
            
            // Re-run current prediction to show/hide details
            if (rbfNetwork && document.getElementById('predictionResultsRBF').innerHTML !== '<p>Train the network and make predictions here...</p>') {
                const lastTestBtn = document.querySelector('[onclick="testTrainingDataRBF()"]');
                if (lastTestBtn) {
                    testTrainingDataRBF();
                }
            }
        }
        
        function createDetailedCalculationHTML(point, pointIndex, prediction) {
            if (!showDetailedCalculations) return '';
            
            // Calculate RBF activations for this point
            const rbfActivations = [];
            const distances = [];
            for (let j = 0; j < rbfNetwork.k; j++) {
                const dist = rbfNetwork.euclideanDistance(point, rbfNetwork.centers[j]);
                distances.push(dist);
                const activation = rbfNetwork.rbf(point, rbfNetwork.centers[j], rbfNetwork.dMax, rbfNetwork.k);
                rbfActivations.push(activation);
            }
            
            // Calculate final output step by step
            let classAOutput = 0;
            let classBOutput = 0;
            let weightCalculations = [];
            
            for (let j = 0; j < rbfNetwork.k; j++) {
                const weightA = rbfNetwork.weights[j][0];
                const weightB = rbfNetwork.weights[j][1];
                const activation = rbfActivations[j];
                
                const contributionA = activation * weightA;
                const contributionB = activation * weightB;
                
                classAOutput += contributionA;
                classBOutput += contributionB;
                
                weightCalculations.push({
                    rbfIndex: j,
                    activation: activation,
                    weightA: weightA,
                    weightB: weightB,
                    contributionA: contributionA,
                    contributionB: contributionB
                });
            }
            
            // Apply softmax for true probabilities
            const softmaxA = Math.exp(prediction[0]) / (Math.exp(prediction[0]) + Math.exp(prediction[1]));
            const softmaxB = Math.exp(prediction[1]) / (Math.exp(prediction[0]) + Math.exp(prediction[1]));
            
            return `
                <div class="detailed-calculations show">
                    <div class="calculation-step">
                        <h5><span class="step-number">1</span>Calculate Distances to RBF Centers</h5>
                        <div class="math-formula">
                            Distance = ‚àö[(x‚ÇÅ - c‚ÇÅ)¬≤ + (x‚ÇÇ - c‚ÇÇ)¬≤]
                        </div>
                        ${rbfNetwork.centers.map((center, j) => `
                            <p>To Center ${j+1} [${center[0].toFixed(3)}, ${center[1].toFixed(3)}]: 
                            ‚àö[(${point[0]} - ${center[0].toFixed(3)})¬≤ + (${point[1]} - ${center[1].toFixed(3)})¬≤] = 
                            <span class="value-highlight">${distances[j].toFixed(3)}</span></p>
                        `).join('')}
                    </div>
                    
                    <div class="calculation-step">
                        <h5><span class="step-number">2</span>Calculate RBF Activations</h5>
                        <div class="math-formula">
                            œÜ(x) = exp(-(k/d_max¬≤) √ó distance¬≤)
                            <br>where k=${rbfNetwork.k}, d_max=${rbfNetwork.dMax.toFixed(3)}
                        </div>
                        ${rbfActivations.map((activation, j) => `
                            <p>RBF${j+1}: exp(-(${rbfNetwork.k}/${rbfNetwork.dMax.toFixed(3)}¬≤) √ó ${distances[j].toFixed(3)}¬≤) = 
                            exp(${(-(rbfNetwork.k / (rbfNetwork.dMax ** 2)) * (distances[j] ** 2)).toFixed(3)}) = 
                            <span class="value-highlight">${activation.toFixed(3)}</span></p>
                        `).join('')}
                    </div>
                    
                    <div class="calculation-step">
                        <h5><span class="step-number">3</span>Apply Output Weights</h5>
                        <div class="math-formula">
                            Output = Œ£(RBF_activation √ó Weight)
                        </div>
                        ${weightCalculations.map(calc => `
                            <p>RBF${calc.rbfIndex + 1} contribution: ${calc.activation.toFixed(3)} √ó [${calc.weightA.toFixed(3)}, ${calc.weightB.toFixed(3)}] = 
                            [<span class="value-highlight">${calc.contributionA.toFixed(3)}</span>, <span class="value-highlight">${calc.contributionB.toFixed(3)}</span>]</p>
                        `).join('')}
                        <div style="border-top: 2px solid #ed8936; margin-top: 10px; padding-top: 10px;">
                            <p><strong>Final Raw Output:</strong> [<span class="value-highlight">${classAOutput.toFixed(3)}</span>, <span class="value-highlight">${classBOutput.toFixed(3)}</span>]</p>
                            <p><strong>As Percentages:</strong> [<span class="value-highlight">${(classAOutput * 100).toFixed(1)}%</span>, <span class="value-highlight">${(classBOutput * 100).toFixed(1)}%</span>]</p>
                        </div>
                    </div>
                    
                    <div class="calculation-step">
                        <h5><span class="step-number">4</span>Convert to Probabilities (Softmax)</h5>
                        <div class="math-formula">
                            P(class_i) = exp(output_i) / Œ£exp(output_j)
                        </div>
                        <p>P(Class A) = exp(${prediction[0].toFixed(3)}) / (exp(${prediction[0].toFixed(3)}) + exp(${prediction[1].toFixed(3)})) = <span class="value-highlight">${(softmaxA * 100).toFixed(1)}%</span></p>
                        <p>P(Class B) = exp(${prediction[1].toFixed(3)}) / (exp(${prediction[0].toFixed(3)}) + exp(${prediction[1].toFixed(3)})) = <span class="value-highlight">${(softmaxB * 100).toFixed(1)}%</span></p>
                    </div>
                    
                    <div style="background: #e6fffa; padding: 15px; border-radius: 10px; margin-top: 15px;">
                        <h4>üí° Why Values > 100%?</h4>
                        <p><strong>RBF networks use LINEAR output layers (no sigmoid activation)</strong></p>
                        <p>‚Ä¢ Raw output = H √ó W (linear combination)</p>
                        <p>‚Ä¢ Can produce any real number (including > 1.0)</p>
                        <p>‚Ä¢ ${classBOutput > 1 ? classBOutput.toFixed(3) + ' = ' + (classBOutput * 100).toFixed(1) + '% means very strong Class B activation' : 'Values < 1.0 mean weaker activation'}</p>
                        <p>‚Ä¢ For classification: use argmax (highest value wins)</p>
                        <p>‚Ä¢ For probabilities: apply softmax normalization</p>
                    </div>
                </div>
            `;
        }
        
        function trainRBF() {
            const k = parseInt(document.getElementById('kCenters').value);
            const maxIter = parseInt(document.getElementById('maxIter').value);
            
            clearLogRBF();
            
            logRBF(`RBF Configuration:
- Input: 2 dimensions
- Centers: ${k} RBF neurons  
- Output: 2 classes
- Max K-means iterations: ${maxIter}\n`);
            
            const startTime = Date.now();
            
            // Initialize and train RBF network
            rbfNetwork = new RBFNetwork(k);
            const result = rbfNetwork.train(X, y);
            
            const endTime = Date.now();
            
            logRBF(`Training completed in ${endTime - startTime}ms`);
            logRBF(`Centers found: ${k}`);
            logRBF(`d_max = ${result.dMax.toFixed(3)}`);
            logRBF(`sigma = ${result.sigma.toFixed(3)}`);
            
            logRBF(`\nüìä Training Process:
1. K-means clustering found ${k} centers
2. Computed spread œÉ = d_max / sqrt(k) = ${result.dMax.toFixed(3)} / sqrt(${k}) = ${result.sigma.toFixed(3)}
3. Built hidden matrix H using Gaussian RBF: œÜ(x) = exp(-(k/d_max¬≤) * ||x-c||¬≤)
4. Solved output weights using pseudo-inverse: W = (H^T H)^-1 H^T y

‚ö†Ô∏è  Important: RBF uses LINEAR output layer (no sigmoid)
   Raw outputs can exceed 1.0 - this is normal!
   For probabilities, apply softmax to raw outputs.`);
            
            // Display centers
            displayCenters(result.centers);
            displayRBFParams(result);
            
            setTimeout(testTrainingDataRBF, 500);
        }
        
        function displayCenters(centers) {
            const centersDiv = document.getElementById('centersDisplay');
            let html = '';
            
            for (let i = 0; i < centers.length; i++) {
                html += `
                    <div class="center-box">
                        <h4>üéØ Center ${i + 1}</h4>
                        <p><strong>x1:</strong> ${centers[i][0].toFixed(3)}</p>
                        <p><strong>x2:</strong> ${centers[i][1].toFixed(3)}</p>
                    </div>
                `;
            }
            
            centersDiv.innerHTML = html;
        }
        
        function displayRBFParams(result) {
            const paramsDiv = document.getElementById('rbfParams');
            paramsDiv.innerHTML = `
                <h3>üìä RBF Parameters</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div><strong>Max Distance (d_max):</strong> ${result.dMax.toFixed(3)}</div>
                    <div><strong>Spread (œÉ):</strong> ${result.sigma.toFixed(3)}</div>
                    <div><strong>Number of Centers:</strong> ${result.centers.length}</div>
                    <div><strong>Weight Matrix Shape:</strong> ${result.weights.length}√ó${result.weights[0].length}</div>
                </div>
                
                <h4>üéØ RBF Centers:</h4>
                <table style="font-size: 0.9em;">
                    <thead>
                        <tr><th>Center</th><th>x1</th><th>x2</th></tr>
                    </thead>
                    <tbody>
                        ${result.centers.map((center, i) => 
                            `<tr><td>Center ${i+1}</td><td>${center[0].toFixed(3)}</td><td>${center[1].toFixed(3)}</td></tr>`
                        ).join('')}
                    </tbody>
                </table>
                
                <h4>üîó Output Weights (W):</h4>
                <table style="font-size: 0.9em;">
                    <thead>
                        <tr><th>RBF Neuron</th><th>To Class A</th><th>To Class B</th></tr>
                    </thead>
                    <tbody>
                        ${result.weights.map((weight, i) => 
                            `<tr><td>Neuron ${i+1}</td><td>${weight[0].toFixed(3)}</td><td>${weight[1].toFixed(3)}</td></tr>`
                        ).join('')}
                    </tbody>
                </table>
                
                <h4>‚ö° Hidden Activation Matrix (H):</h4>
                <table style="font-size: 0.9em;">
                    <thead>
                        <tr><th>Point</th>${result.centers.map((_, i) => `<th>RBF ${i+1}</th>`).join('')}<th>Distance Details</th></tr>
                    </thead>
                    <tbody>
                        ${result.hiddenMatrix.map((row, i) => {
                            const distances = result.centers.map(center => 
                                rbfNetwork.euclideanDistance(X[i], center).toFixed(3)
                            );
                            return `<tr>
                                <td>Point ${i+1}</td>
                                ${row.map(val => `<td>${val.toFixed(3)}</td>`).join('')}
                                <td>[${distances.join(', ')}]</td>
                            </tr>`;
                        }).join('')}
                    </tbody>
                </table>
                
                <div style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-top: 15px;">
                    <strong>‚ö†Ô∏è Note:</strong> RBF networks use linear output layers, so predictions can exceed 1.0 (100%). 
                    This is normal - the raw output represents activation strength, not probability.
                </div>
            `;
        }
        
        function makePredictionRBF() {
            if (!rbfNetwork) {
                alert('Please train the RBF network first!');
                return;
            }
            
            const x1 = parseFloat(document.getElementById('predX1RBF').value);
            const x2 = parseFloat(document.getElementById('predX2RBF').value);
            const inputPoint = [x1, x2];
            
            const result = rbfNetwork.predict([inputPoint]);
            const prediction = result.predictions[0];
            
            // Apply softmax for true probabilities
            const softmaxA = Math.exp(prediction[0]) / (Math.exp(prediction[0]) + Math.exp(prediction[1]));
            const softmaxB = Math.exp(prediction[1]) / (Math.exp(prediction[0]) + Math.exp(prediction[1]));
            
            let resultsHTML = `
                <h3>üéØ RBF Prediction for input [${x1}, ${x2}]:</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div style="text-align: center; padding: 15px; background: #fed7d7; border-radius: 10px;">
                        <strong>Class A</strong><br>
                        <span style="font-size: 1.2em; color: #e53e3e;">Raw: ${prediction[0].toFixed(3)}</span><br>
                        <span style="font-size: 1.5em; color: #e53e3e;">Prob: ${(softmaxA * 100).toFixed(1)}%</span>
                    </div>
                    <div style="text-align: center; padding: 15px; background: #c6f6d5; border-radius: 10px;">
                        <strong>Class B</strong><br>
                        <span style="font-size: 1.2em; color: #38a169;">Raw: ${prediction[1].toFixed(3)}</span><br>
                        <span style="font-size: 1.5em; color: #38a169;">Prob: ${(softmaxB * 100).toFixed(1)}%</span>
                    </div>
                </div>
                <div style="text-align: center; margin: 15px 0; font-size: 1.2em;">
                    <strong>Predicted Class: ${prediction[0] > prediction[1] ? 'A' : 'B'}</strong>
                </div>
            `;
            
            // Add detailed calculations if enabled
            if (showDetailedCalculations) {
                resultsHTML += `
                    <div style="background: white; padding: 20px; border-radius: 15px; border: 2px solid #ed8936; margin-top: 20px;">
                        <h4 style="color: #ed8936; margin-top: 0;">üîç Step-by-Step Calculation:</h4>
                        ${createDetailedCalculationHTML(inputPoint, -1, prediction)}
                    </div>
                `;
            } else {
                resultsHTML += `
                    <div style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;">
                        <p>üí° Click <strong>"üîç Show Detailed Math"</strong> button above to see the complete step-by-step calculation!</p>
                    </div>
                `;
            }
            
            document.getElementById('predictionResultsRBF').innerHTML = resultsHTML;
        }
        
        function testTrainingDataRBF() {
            if (!rbfNetwork) {
                alert('Please train the RBF network first!');
                return;
            }
            
            const result = rbfNetwork.predict(X);
            let resultsHTML = '<h3>‚úÖ RBF Training Data Predictions:</h3>';
            
            // Summary table first
            resultsHTML += '<table style="width: 100%; margin-bottom: 20px;"><thead><tr><th>Input</th><th>Target</th><th>Raw Output</th><th>Predicted Class</th><th>Accuracy</th></tr></thead><tbody>';
            
            let totalAccuracy = 0;
            
            for (let i = 0; i < X.length; i++) {
                const prediction = result.predictions[i];
                const targetClass = y[i][0] > y[i][1] ? 'A' : 'B';
                const predictedClass = prediction[0] > prediction[1] ? 'A' : 'B';
                const isCorrect = targetClass === predictedClass;
                
                totalAccuracy += isCorrect ? 1 : 0;
                
                resultsHTML += `
                    <tr style="background: ${isCorrect ? '#c6f6d5' : '#fed7d7'}">
                        <td>[${X[i][0]}, ${X[i][1]}]</td>
                        <td>Class ${targetClass}</td>
                        <td>[${prediction[0].toFixed(3)}, ${prediction[1].toFixed(3)}]</td>
                        <td>Class ${predictedClass}</td>
                        <td>${isCorrect ? '‚úÖ Correct' : '‚ùå Wrong'}</td>
                    </tr>
                `;
            }
            
            resultsHTML += `</tbody></table>`;
            resultsHTML += `<div style="text-align: center; margin: 20px 0; font-size: 1.2em;"><strong>Overall Accuracy: ${((totalAccuracy / X.length) * 100).toFixed(1)}%</strong></div>`;
            
            // Add detailed calculations if enabled
            if (showDetailedCalculations) {
                resultsHTML += '<h4>üîç Detailed Step-by-Step Calculations:</h4>';
                
                for (let i = 0; i < X.length; i++) {
                    const point = X[i];
                    const prediction = result.predictions[i];
                    const targetClass = y[i][0] > y[i][1] ? 'A' : 'B';
                    const predictedClass = prediction[0] > prediction[1] ? 'A' : 'B';
                    
                    resultsHTML += `
                        <div style="background: white; margin: 20px 0; padding: 20px; border-radius: 15px; border: 2px solid ${targetClass === predictedClass ? '#38a169' : '#e53e3e'};">
                            <h4 style="color: #ed8936; margin-top: 0;">üìç Point ${i+1}: [${point[0]}, ${point[1]}] ‚Üí Target: Class ${targetClass}, Predicted: Class ${predictedClass}</h4>
                            ${createDetailedCalculationHTML(point, i, prediction)}
                        </div>
                    `;
                }
            } else {
                resultsHTML += `
                    <div style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;">
                        <p>üí° Click <strong>"üîç Show Detailed Math"</strong> button above to see step-by-step calculations for each prediction!</p>
                    </div>
                `;
            }
            
            // Add explanation
            resultsHTML += `
                <div style="background: #e6fffa; padding: 15px; border-radius: 10px; margin-top: 20px;">
                    <h4>üßÆ Understanding RBF Output Values</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <h5>üîó MLP vs RBF</h5>
                            <p><strong>MLP:</strong> Sigmoid ‚Üí [0, 1]</p>
                            <p><strong>RBF:</strong> Linear ‚Üí (-‚àû, +‚àû)</p>
                        </div>
                        <div>
                            <h5>üìä Interpretation</h5>
                            <p><strong>Raw > 1.0:</strong> Strong activation</p>
                            <p><strong>Raw < 0:</strong> Negative evidence</p>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('predictionResultsRBF').innerHTML = resultsHTML;
        }
        
        function resetRBF() {
            rbfNetwork = null;
            document.getElementById('trainingLogRBF').textContent = 'Ready to train RBF...';
            document.getElementById('centersDisplay').innerHTML = '<p>Train the network to see RBF centers...</p>';
            document.getElementById('rbfParams').innerHTML = '<p>RBF parameters will appear here after training...</p>';
            document.getElementById('predictionResultsRBF').innerHTML = '<p>Train the network and make predictions here...</p>';
        }
        
        // Initialize on load
        initializeDisplay();
    </script>
</body>
</html>